# Password Hashing and Brute-force Demonstrator
# ---------------------------------------------------
# This program demonstrates brute-force cracking of 4-digit PINs
# using plaintext and salted hashes (SHA-256, SHA-512).
# It also estimates password crack times for Argon2, bcrypt, and PBKDF2
# based on timing benchmarks from the user's machine.

import time
import hashlib
import random
import string
import itertools
import bcrypt
from argon2 import PasswordHasher
from hashlib import pbkdf2_hmac
import math

# Estimated cracking speeds for different attacker profiles
attacker_profiles = {
    "Hobbyist": 10,                        # 10 hashes/sec
    "Mid-tier GPU rig": 100_000,          # 100K hashes/sec
    "High-end GPU farm": 10_000_000,      # 10M hashes/sec
    "Nation-State (ASICs)": 1_000_000_000 # 1B hashes/sec
}

def sha_512_brute(salt_length_input, user_pincode):
    """
    Attempts to brute-force a salted SHA-512 hash of a 4-digit PIN.

    Parameters:
        salt_length_input (int): Length of the randomly generated salt.
        user_pincode (str): The user-provided 4-digit PIN to hash and later crack.

    Behavior:
        Generates a salted SHA-512 hash of the PIN and attempts to recover it
        by brute-forcing all salt + PIN combinations.
    """
    chars = string.ascii_letters + string.digits
    salt_length = int(salt_length_input)
    total_space = (len(chars) ** salt_length) * 10000

    # Generate a random salt of specified length
    salt = ''.join(random.choices(chars, k=salt_length))
    sha512_hash = hashlib.sha512((salt + user_pincode).encode()).hexdigest()
    print(f"\n{user_pincode} in SHA-512 is: ")
    print(f"{sha512_hash}")

    while True:
        print("\nEnter '1' to start brute force crack")
        print("Enter '2' to return to previous menu")
        choice = input("Enter Choice: ")

        if choice == '1':
            start_time = time.time()
            attempts = 0

            # Try all salt combinations
            for salt_tuple in itertools.product(chars, repeat=salt_length):
                test_salt = ''.join(salt_tuple)

                # Try all 4-digit PINs
                for i in range(10000):
                    attempts += 1
                    guess = f"{i:04d}"
                    guess_hash = hashlib.sha512((test_salt + guess).encode()).hexdigest()

                    # Track speed and progress
                    elapsed_so_far = time.time() - start_time
                    speed = attempts / elapsed_so_far if elapsed_so_far > 0 else 0
                    progress = (attempts / total_space) * 100

                    print(f"\rAttempts: {attempts:,} ({progress:.2f}%) — {speed:,.0f} attempts/s", end="")

                    if guess_hash == sha512_hash:
                        elapsed = time.time() - start_time
                        average_speed = attempts / elapsed if elapsed > 0 else 0

                        print("Pincode Cracked!")
                        print(f"\n- PIN:       {guess}")
                        print(f"- Salt:      {test_salt}")
                        print(f"- Attempts:  {attempts:,}")
                        print(f"- Time:      {elapsed:.2f} seconds")
                        print(f"- Avg speed: {average_speed:,.0f} attempts/sec")

                        post_sha_brute_menu(user_pincode)

        elif choice == '2':
            sha_512_menu(user_pincode)
        else:
            print("Invalid Input")

# Menu to select salt length for SHA-512 brute force
def sha_512_menu(user_pincode):
    """
    Displays menu for selecting the salt length used in the SHA-512 brute force attack.

    Parameters:
        user_pincode (str): The current 4-digit PIN chosen or generated by the user.
    """
    print("\nChoose the salt length for SHA-512 brute force:")
    while True:
        print("1) 1 salt - 620,000 possibilities - 8.1 seconds approx")
        print("2) 2 salt - 38,440,000 possibilities - 8.4 minutes approx")
        print("3) 3 salt - 2.38 billion possibilities - 8.7 hours approx")
        print("4) 4 salt - 148 billion possibilities - 22.5 days approx")
        print("5) Return to previous menu")

        choice = input("Enter Choice: ")
        if choice in {'1','2','3','4'}:
            sha_512_brute(int(choice), user_pincode)
        elif choice == '5': 
            pincode_main_menu(user_pincode)
        else:
            print("Invalid input, please enter 1-5")

# Brute-force crack a salted SHA-256 hash of a 4-digit PIN
def sha_256_brute(salt_length_input, user_pincode):
    """
    Attempts to brute-force a salted SHA-256 hash of a 4-digit PIN.

    Parameters:
        salt_length_input (int): Length of the salt to generate.
        user_pincode (str): The 4-digit PIN to hash and later recover.
    """
    chars = string.ascii_letters + string.digits
    salt_length = int(salt_length_input)
    total_space = (len(chars) ** salt_length) * 10000

    # Generate a random salt and compute the SHA-256 hash
    salt = ''.join(random.choices(chars, k=salt_length))
    sha256_hash = hashlib.sha256((salt + user_pincode).encode()).hexdigest()
    print(f"\n{user_pincode} in SHA-256 is: ")
    print(f"{sha256_hash}")

    while True:
        print("\nEnter '1' to start brute force crack")
        print("Enter '2' to return to previous menu")

        choice = input("Enter Choice: ")

        if choice == '1':
            start_time = time.time()
            attempts = 0

            # Loop through all possible salts and 4-digit PINs
            for salt_tuple in itertools.product(chars, repeat=salt_length):
                test_salt = ''.join(salt_tuple)

                for i in range(10000):
                    attempts += 1
                    guess = f"{i:04d}"
                    guess_hash = hashlib.sha256((test_salt + guess).encode()).hexdigest()

                    elapsed_so_far = time.time() - start_time
                    speed = attempts / elapsed_so_far if elapsed_so_far > 0 else 0
                    progress = (attempts / total_space) * 100

                    print(f"\rAttempts: {attempts:,} ({progress:.2f}%) — {speed:,.0f} attempts/s", end="")

                    if guess_hash == sha256_hash:
                        elapsed = time.time() - start_time
                        average_speed = attempts / elapsed if elapsed > 0 else 0

                        print("Pincode Cracked!")
                        print(f"\n- PIN:       {guess}")
                        print(f"- Salt:      {test_salt}")
                        print(f"- Attempts:  {attempts:,}")
                        print(f"- Time:      {elapsed:.2f} seconds")
                        print(f"- Avg speed: {average_speed:,.0f} attempts/sec")

                        post_sha_brute_menu(user_pincode)

        elif choice == '2':
            sha_256_menu(user_pincode)
        else:
            print("Invalid Input")

# Menu for SHA-256 brute force
def sha_256_menu(user_pincode):
    """
    Displays menu for selecting the salt length used in the SHA-256 brute force attack.

    Parameters:
        user_pincode (str): The current 4-digit PIN to be hashed and cracked.
    """
    print("\nChoose the salt length for SHA-256 brute force:")
    while True:
        print("1) 1 salt - 620,000 possibilities - 8.1 seconds approx")
        print("2) 2 salt - 38,440,000 possibilities - 8.4 minutes approx")
        print("3) 3 salt - 2.38 billion possibilities - 8.7 hours approx")
        print("4) 4 salt - 148 billion possibilities - 22.5 days approx")
        print("5) Return to previous menu")

        choice = input("Enter Choice: ")
        if choice == '1':
            salt_length_input = 1
            sha_256_brute(salt_length_input, user_pincode)
        elif choice == '2':
            salt_length_input = 2
            sha_256_brute(salt_length_input, user_pincode)
        elif choice == '3':
            salt_length_input = 3
            sha_256_brute(salt_length_input, user_pincode)
        elif choice == '4':
            salt_length_input = 4
            sha_256_brute(salt_length_input, user_pincode)
        elif choice == '5': 
            pincode_main_menu(user_pincode)
        else:
            print("Invalid input, please enter 1, 2, 3, 4 or 5")

# Prompts the user with post-crack options after SHA-256 brute-force completes
def post_sha_brute_menu(user_pincode):
    """
    Displays a menu of next-step options after a successful SHA brute-force attempt.

    Parameters:
        user_pincode (str): The 4-digit PIN that was just cracked.

    Behavior:
        Allows the user to return to the main menu, re-enter the PIN menu,
        choose a new PIN, or exit the program.
    """
    while True:
        print("\nWhat would you like to do?")
        print("1) Return to main menu")
        print("2) Return to pincode menu")
        print("3) Choose another pincode")
        print("4) Exit program")
        choice = input("Enter Choice: ")

        if choice == '1':
            main_menu()
        elif choice == '2':
            pincode_main_menu(user_pincode)
        elif choice == '3':
            pincode_input_validator()
        elif choice == '4':
            print("Exiting program...")
            exit()
        else:
            print("Invalid Input")

# Perform brute-force attack against a plaintext (unsalted) 4-digit PIN
def pincode_plaintext_brute(user_pincode):
    """
    Performs a plaintext brute-force attack on a 4-digit PIN.

    Parameters:
        user_pincode (str): The 4-digit PIN to be brute-forced.
    """
    start_time = time.time()

    for i in range(10000):
        guess = f"{i:04d}"  # Zero-padded 4-digit guess
        print(f"{guess}")

        if guess == user_pincode:
            end_time = time.time()
            elapsed = end_time - start_time
            print(f"\nPassword {guess} cracked in {elapsed:.2f} seconds")
            return

# Generate a random 4-digit PIN and pass it to the PIN menu
def generate_random_pin():
    """
    Generates a random 4-digit PIN and routes to the pincode menu.
    """
    user_pincode = f"{random.randint(0, 9999):04d}"  # Random PIN in 0000–9999
    print(f"\nPincode generated: {user_pincode}")
    pincode_main_menu(user_pincode)

# Ask user whether to generate or input a 4-digit PIN
def pincode_input_validator():
    """
    Prompts the user to either choose or generate a 4-digit PIN.

    Routes to the next appropriate step based on input.
    """
    while True:
        print("\nWould you like to choose a pincode or generate one randomly?")
        print("1) Choose my own")
        print("2) Generate randomly")
        choice = input("Enter Choice: ")

        if choice == '1':
            while True:
                user_pincode = input("Choose a 4 digit pincode (i.e 0000): ")
                # Ensure it's exactly 4 numeric digits
                if len(user_pincode) == 4 and user_pincode.isdigit():
                    break
                else:
                    print("Invalid input...")
            pincode_main_menu(user_pincode)

        elif choice == '2':
            generate_random_pin()
        else:
            print("Invalid Input, choose '1' or '2'")

# Show user menu after PIN is chosen/generated
def pincode_main_menu(user_pincode):
    """
    Main menu for PIN-based brute force options.

    Parameters:
        user_pincode (str): The user-selected or randomly generated PIN.
    """
    while True:
        print("\nPincode Menu")

        print("\nWhat would you like to do?")
        print("1) Plaintext brute force")
        print("2) SHA-256 with salt")
        print("3) SHA-512 with salt")
        print("4) Choose another pincode")
        print("5) Return to main menu")
        choice = input("Enter Choice: ")

        if choice == '1':
            pincode_plaintext_brute(user_pincode)
        elif choice == '2':
            sha_256_menu(user_pincode)
        elif choice == '3':
            sha_512_menu(user_pincode)
        elif choice == '4':
            pincode_input_validator()
        elif choice == '5':
            main_menu()
        else:
            print("Invalid input, please choose 1, 2 or 3")

# Estimate entropy of a password based on character diversity and length
def estimate_entropy(password):
    """
    Estimates the entropy (in bits) of a given password based on character set size.

    Parameters:
        password (str): The password to analyze.

    Returns:
        int: Estimated entropy in bits.
    """
    charset = 0
    if any(c in string.ascii_lowercase for c in password):
        charset += 26
    if any(c in string.ascii_uppercase for c in password):
        charset += 26
    if any(c in string.digits for c in password):
        charset += 10
    if any(c in string.punctuation for c in password):
        charset += len(string.punctuation)

    if charset == 0:
        return 0  # Avoid log2(0)

    # Shannon entropy estimate: log2(possible_symbols) × password length
    entropy_bits = int(len(password) * math.log2(charset))
    return entropy_bits

# Calculate estimated brute-force time from entropy and hashing time
def estimate_crack_time(hash_time, entropy_bits):
    """
    Estimates time to brute-force a password based on hash time and entropy.

    Parameters:
        hash_time (float): Time to compute one hash on user's hardware.
        entropy_bits (int): Estimated entropy of the password.

    Returns:
        float: Estimated time (in seconds) to brute-force the password.
    """
    guesses = 2 ** entropy_bits
    return guesses * hash_time

# Converts seconds to readable time format, from seconds to trillions of years
def format_time(seconds):
    """
    Converts a time duration in seconds into a human-readable format.

    Parameters:
        seconds (float): Time in seconds.

    Returns:
        str: Time formatted as seconds, minutes, hours, or years.
    """
    trillion = 1e12
    billion = 1e9
    million = 1e6
    year_in_seconds = 3.154e7  # One year ≈ 31,540,000 seconds

    years = seconds / year_in_seconds

    if years > trillion:
        return f"{years / trillion:,.2f} trillion years"
    elif years > billion:
        return f"{years / billion:,.2f} billion years"
    elif years > million:
        return f"{years / million:,.2f} million years"
    elif years > 1:
        return f"{years:,.2f} years"
    elif seconds > 3600:
        return f"{seconds / 3600:,.2f} hours"
    elif seconds > 60:
        return f"{seconds / 60:,.2f} minutes"
    else:
        return f"{seconds:,.2f} seconds"

# Entry point for the Realistic Password Crack Estimator (RPCE) tool
def rpce_menu():
    """
    Launches the Realistic Password Crack Estimator tool.

    Allows the user to enter a password and benchmark its hashing strength.
    """
    print("\nPasswords in real life use a hashing tool similar to Argon2, bcrypt or PBKDF2.")
    print("This tool allows you to enter a password, and see how long a brute force attack")
    print("would take to crack it, based on the hashing algorithm and your systems hardware.")

    print("\nWhat would you like to do?")

    while True:
        print("1) Enter a password to estimate crack time")
        print("2) Return to main menu")
        choice = input("Enter Choice: ")

        if choice == '1':
            password = input("Enter your password: ")
            benchmark_hash_algorithms(password)
            break
        elif choice == '2':
            main_menu()
            break
        else:
            print("Invalid input, please choose 1 or 2")

# Menu shown after RPCE finishes, lets user continue or return
def post_rpce_menu():
    """
    Displays post-estimation options after running the password benchmark.
    """
    print("\nWhat would you like to do next?")
    while True:
        print("1) Test another password")
        print("2) Return to main menu")
        choice = input("Enter Choice: ")

        if choice == '1':
            rpce_menu()
            break
        elif choice == '2':
            main_menu()
            break
        else:
            print("Invalid input, please choose 1 or 2")

# Print crack time estimates for each attacker profile
def display_crack_times(entropy_bits, argon_time, bcrypt_time, pbkdf2_time):
    """
    Prints estimated crack times based on attacker profiles.

    Parameters:
        entropy_bits (int): Estimated entropy of the password.
        argon_time (float): Time to hash using Argon2.
        bcrypt_time (float): Time to hash using bcrypt.
        pbkdf2_time (float): Time to hash using PBKDF2-HMAC-SHA256.
    """
    print("\nEstimated crack times by attacker profile:")
    for profile, rate in attacker_profiles.items():
        print(f"\n{profile}:")
        print(f"- Argon2   : {format_time((2 ** entropy_bits) * argon_time / rate)}")
        print(f"- Bcrypt   : {format_time((2 ** entropy_bits) * bcrypt_time / rate)}")
        print(f"- PBKDF2   : {format_time((2 ** entropy_bits) * pbkdf2_time / rate)}")

# Benchmark hashing algorithms and estimate crack time for each
def benchmark_hash_algorithms(password):
    """
    Benchmarks Argon2, bcrypt, and PBKDF2 hashing times for a given password.

    Parameters:
        password (str): The password to test.

    Behavior:
        Displays time to hash and estimated crack time based on entropy and attacker profiles.
    """
    entropy_bits = estimate_entropy(password)
    print(f"\nEstimated entropy: {entropy_bits} bits")

    # --- Argon2 ---
    ph = PasswordHasher(time_cost=2, memory_cost=102400, parallelism=8)
    start = time.time()
    ph.hash(password)
    argon_time = time.time() - start
    argon_crack = estimate_crack_time(argon_time, entropy_bits)

    # --- Bcrypt ---
    bcrypt_password = password.encode()
    start = time.time()
    bcrypt.hashpw(bcrypt_password, bcrypt.gensalt(rounds=12))
    bcrypt_time = time.time() - start
    bcrypt_crack = estimate_crack_time(bcrypt_time, entropy_bits)

    # --- PBKDF2-HMAC-SHA256 ---
    salt = b"static_salt"
    start = time.time()
    pbkdf2_hmac('sha256', password.encode(), salt, 100_000)
    pbkdf2_time = time.time() - start
    pbkdf2_crack = estimate_crack_time(pbkdf2_time, entropy_bits)

    # Display results with timing per hash and formatted crack time
    print("\nHashing & Cracking Estimates (on your computer):")
    print(f"Argon2   : {argon_time:.4f}s/hash — Estimated crack time: {format_time(argon_crack)}")
    print(f"Bcrypt   : {bcrypt_time:.4f}s/hash — Estimated crack time: {format_time(bcrypt_crack)}")
    print(f"PBKDF2   : {pbkdf2_time:.4f}s/hash — Estimated crack time: {format_time(pbkdf2_crack)}")

    # Ask user whether they want to see attacker profile estimates
    while True:
        print("\nWould you like to see estimated crack times based on different attacker profiles?")
        print("1) Yes")
        print("2) No, return to previous menu")
        choice = input("Enter Choice: ")

        if choice == '1':
            display_crack_times(entropy_bits, argon_time, bcrypt_time, pbkdf2_time)
            break
        elif choice == '2':
            post_rpce_menu()
            break
        else:
            print("Invalid input, please choose 1 or 2")

    post_rpce_menu()

# Main navigation menu
def main_menu():
    """
    Displays the main navigation menu and routes to core modules.
    """
    while True:
        print("\nWelcome to my password hashing and brute force demo!")
        print("Please select one of the following options:")
        print("1) Pincode Cracker")
        print("2) Realistic Password Crack Estimator")
        print("3) Exit")

        choice = input("Enter Choice: ")

        if choice == '1':
            pincode_input_validator()
        elif choice == '2':
            rpce_menu()
        elif choice == '3':
            print("Exiting Program...")
            exit()
        else:
            print("Invalid input, please choose 1, 2 or 3")

# Standard entry point in Python scripts
if __name__ == "__main__":
    main_menu()